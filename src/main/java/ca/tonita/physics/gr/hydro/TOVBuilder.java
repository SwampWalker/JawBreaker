/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.tonita.physics.gr.hydro;

import ca.tonita.jawbreaker.equationsOfState.TabulatedHermite;
import ca.tonita.jawbreaker.models.TOVData;
import ca.tonita.math.numerical.RK4;
import ca.tonita.math.numerical.spectral.SpectralSolver1D;
import ca.tonita.math.polynomials.ChebyshevExtrema;
import ca.tonita.math.polynomials.LinearlyMappedBasis;
import java.util.ArrayList;

/**
 *
 * @author atonita
 */
public class TOVBuilder {

    /**
     * No constructing this guy.
     */
    private TOVBuilder() {
    }

    /**
     * Evolves the TOV equations using RK4 method.
     *
     * @param tov a <code>TOVData</code> object to store the result
     * @param eos the equation of state to use
     * @param centralPressure the central pressure of the star
     * @param stepSize the step size to use for the RK4
     * @param outputEvery how often to output data
     * @param minPressure the value of pressure to terminate evolution at (the
     * effective surface pressure)
     */
    public static void evolve(TOVData tov, TabulatedHermite eos, double centralPressure, double stepSize, int outputEvery, double minPressure) {
        TOVEquations eqns = new TOVEquations(eos);
        ArrayList<double[]> points = tov.getVariables();
        ArrayList<Double> radii = tov.getRadii();
        points.clear();
        points.add(new double[]{centralPressure, 0, 0, 0});
        radii.clear();
        radii.add(0.);
        int maxSteps = Integer.MAX_VALUE;
        TOVTerminator terminator = new TOVTerminator(maxSteps * stepSize, maxSteps, minPressure);
        RK4.evolve(points, radii, eqns, stepSize, outputEvery, terminator);
        tov.setConservedMass(eos.getParticleMass()*points.get(points.size()-1)[3]);
    }

    /**
     * Evolves the TOV equations using RK4 to intialise a guess for a spectral
     * solution to the equations.
     *
     * @param tov a <code>TOVData</code> object to store the result
     * @param guess a <code>TOVData</code> generated by RK4 to use as the guess
     * @param eos the equation of state to use
     * @param basis the <code>LinearlyMappedBasis</code> to use for the spectral
     * solution
     */
    public static void spectralSolution(TOVData tov, TOVData guess, TabulatedHermite eos, LinearlyMappedBasis basis) {
        // Set up for the interpolation.
        TOVEquations eqns = new TOVEquations(eos); // TODO: stick these in a static hashmap? Will create problems when EOSs are deleted.
        eqns.setCentralPressure(guess.getPressure(0));
        basis.setRight(guess.getRadius());
        double[] spectralRadii = basis.getAbscissas();
        ArrayList<Double> radii = guess.getRadii();
        ArrayList<double[]> newPoints = new ArrayList<double[]>();

        // First point is the same.
        newPoints.add(new double[]{guess.getPressure(0), 0, 0});
        double deltaR = radii.get(1);
        int iRadii = 0;
        for (int i = 1; i < spectralRadii.length - 1; i++) {
            while (Math.abs(radii.get(iRadii) - spectralRadii[i]) > deltaR) {
                iRadii++;
            }
            if (radii.get(iRadii) > spectralRadii[i]) {
                iRadii--;
            }
            double[] newPoint = RK4.step(guess.getVariables(iRadii), radii.get(iRadii), eqns, Math.abs(radii.get(iRadii) - spectralRadii[i]));
            newPoints.add(newPoint);
        }
        // Last point we read off.
        newPoints.add(guess.getVariables(radii.size() - 1));
        
        // Set the guess data.
        ArrayList<Double> newRadii = new ArrayList<Double>();
        for (double r: spectralRadii) {
            newRadii.add(r);
        }
        
        // Solve.
        SpectralSolver1D solver = new SpectralSolver1D(eqns, new LinearlyMappedBasis[]{basis});
        ArrayList[] variables = new ArrayList[]{newPoints};
        solver.setGuess(variables, new double[]{basis.getDomain()[1]});
        solver.solve(1.0e-19, 20);
        
        // Reset the data.
        newRadii.clear();
        spectralRadii = basis.getAbscissas();
        for (double r: spectralRadii) {
            newRadii.add(r);
        }
        newPoints.clear();
        double[][][] solution = solver.getSolution();
        for (int i = 0; i < basis.getRank(); i++) {
            double[] y = new double[]{solution[0][0][i], solution[0][1][i], solution[0][2][i], 1};
            newPoints.add(y);
        }
        
        tov.setRadii(newRadii);
        tov.setVariables(newPoints);
        tov.computeSecondaries(eos);
    }
    
    public ArrayList<TOVData> continuation(TabulatedHermite eos, TOVData base, int maxRank) {
        // Set up the system.
        TOVEquations eqns = new TOVEquations(eos);
        ArrayList<TOVData> solutions = new ArrayList<TOVData>();
        LinearlyMappedBasis basis = new LinearlyMappedBasis(new ChebyshevExtrema());
        basis.setDomain(new double[]{0, base.getRadius()});
        basis.setRank(base.getNPoints());
        SpectralSolver1D solver = new SpectralSolver1D(eqns, new LinearlyMappedBasis[]{basis});
        
        // Continuation.
        while (basis.getRank() < maxRank) {
            int newRank = basis.getRank() + 1;
            double[] newX = basis.getAbscissas();
        }
        return solutions;
    }
}
