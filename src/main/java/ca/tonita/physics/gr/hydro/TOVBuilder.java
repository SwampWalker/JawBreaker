/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ca.tonita.physics.gr.hydro;

import ca.tonita.jawbreaker.equationsOfState.TabulatedHermite;
import ca.tonita.jawbreaker.models.TOVFamily;
import ca.tonita.math.numerical.RK4;
import ca.tonita.math.numerical.spectral.SpectralSolver1D;
import ca.tonita.math.polynomials.ChebyshevExtrema;
import ca.tonita.math.polynomials.LinearlyMappedBasis;
import java.util.ArrayList;

/**
 *
 * @author atonita
 */
public class TOVBuilder {

    /**
     * No constructing this guy.
     */
    private TOVBuilder() {
    }

    /**
     * Evolves the TOV equations using RK4 method.
     *
     * @param tov a <code>TOVData</code> object to store the result
     * @param eos the equation of state to use
     * @param centralPressure the central pressure of the star
     * @param stepSize the step size to use for the RK4
     * @param outputEvery how often to output data
     * @param minPressure the value of pressure to terminate evolution at (the
     * effective surface pressure)
     */
    public static void evolve(TOVData tov, TabulatedHermite eos, double centralPressure, double stepSize, int outputEvery, double minPressure) {
        TOVEquations eqns = new TOVEquations(eos);
        ArrayList<double[]> points = tov.getVariables();
        ArrayList<Double> radii = tov.getRadii();
        points.clear();
        points.add(new double[]{centralPressure, 0, 0, 0});
        radii.clear();
        radii.add(0.);
        int maxSteps = Integer.MAX_VALUE;
        TOVTerminator terminator = new TOVTerminator(maxSteps * stepSize, maxSteps, minPressure);
        RK4.evolve(points, radii, eqns, stepSize, outputEvery, terminator);
        tov.computeSecondaries(eos);
    }

    /**
     * Evolves the TOV equations using RK4 to intialise a guess for a spectral
     * solution to the equations.
     *
     * @param tov a <code>TOVData</code> object to store the result
     * @param guess a <code>TOVData</code> generated by RK4 to use as the guess
     * @param eos the equation of state to use
     * @param basis the <code>LinearlyMappedBasis</code> to use for the spectral
     * solution
     */
    public static void spectralSolution(TOVData tov, TOVData guess, TabulatedHermite eos, LinearlyMappedBasis basis) {
        // Set up for the interpolation.
        TOVEquations eqns = new TOVEquations(eos); // TODO: stick these in a static hashmap? Will create problems when EOSs are deleted.
        eqns.setCentralPressure(guess.getPressure(0));
        basis.setRight(guess.getRadius());
        double[] spectralRadii = basis.getAbscissas();
        ArrayList<Double> radii = guess.getRadii();
        ArrayList<double[]> newPoints = new ArrayList<double[]>();

        // First point is the same.
        newPoints.add(new double[]{guess.getPressure(0), 0, 0});
        double deltaR = radii.get(1);
        int iRadii = 0;
        for (int i = 1; i < spectralRadii.length - 1; i++) {
            while (Math.abs(radii.get(iRadii) - spectralRadii[i]) > deltaR) {
                iRadii++;
            }
            if (radii.get(iRadii) > spectralRadii[i]) {
                iRadii--;
            }
            double[] newPoint = RK4.step(guess.getVariables(iRadii), radii.get(iRadii), eqns, Math.abs(radii.get(iRadii) - spectralRadii[i]));
            newPoints.add(newPoint);
        }
        // Last point we read off.
        newPoints.add(guess.getVariables(radii.size() - 1));

        // Set the guess data.
        ArrayList<Double> newRadii = new ArrayList<Double>();
        for (double r : spectralRadii) {
            newRadii.add(r);
        }

        // Solve.
        SpectralSolver1D solver = new SpectralSolver1D(eqns, new LinearlyMappedBasis[]{basis});
        ArrayList[] variables = new ArrayList[]{newPoints};
        solver.setGuess(variables, new double[]{basis.getDomain()[1]});
        solver.solve(1.0e-19, 20);

        // Reset the data.
        newRadii.clear();
        spectralRadii = basis.getAbscissas();
        for (double r : spectralRadii) {
            newRadii.add(r);
        }
        newPoints.clear();
        double[][][] solution = solver.getSolution();
        for (int i = 0; i < basis.getRank(); i++) {
            double[] y = new double[]{solution[0][0][i], solution[0][1][i], solution[0][2][i], 1};
            newPoints.add(y);
        }

        tov.setRadii(newRadii);
        tov.setVariables(newPoints);
        tov.computeSecondaries(eos);
    }

    public static ArrayList<TOVData> continuation(TabulatedHermite eos, TOVData base, int maxRank) {
        // Set up the system.
        TOVEquations eqns = new TOVEquations(eos);
        ArrayList<TOVData> solutions = new ArrayList<TOVData>();
        LinearlyMappedBasis basis = new LinearlyMappedBasis(new ChebyshevExtrema());
        basis.setDomain(new double[]{0, base.getRadius()});
        basis.setRank(base.getNPoints());
        SpectralSolver1D solver = new SpectralSolver1D(eqns, new LinearlyMappedBasis[]{basis});

        // Continuation.
        while (basis.getRank() < maxRank) {
            int newRank = basis.getRank() + 1;
            double[] newX = basis.getAbscissas();
        }
        return solutions;
    }
    public static final int LINEARLY_SPACED = 0;
    public static final int LOGARITHMICALLY_SPACED = 1;
    public static final int QUADRATICLY_SPACED = 2;

    /**
     * Fills the given TOVFamily with TOVData. The equation of state is
     * retrieved from the TOVFamily.
     *
     * @param family The TOVFamily to add the TOVData objects to.
     * @param nTOVs The number of TOVs to create the family with
     * @param minFamilyPressure The central pressure of the first star in the
     * family.
     * @param maxFamilyPressure The central pressure of the last star in the
     * family.
     * @param method The method to use for spacing (Linear, Log, Quadratic).
     * @param stepSize the step size to use for the RK4
     * @param outputEvery how often to output data
     * @param minPressure the value of pressure to terminate evolution at (the
     * effective surface pressure)
     * @param findMaxima Whether to include the maxima in the family, or just
     * the outlined sequence above.
     * @throws IllegalArgumentException If the findMaxima is set to true but the
     * described family doesn't straddle the maximum
     */
    public static void fillFamily(TOVFamily family, int nTOVs, double minFamilyPressure, double maxFamilyPressure, int method, double stepSize, int outputEvery, double minPressure, boolean findMaxima) throws IllegalArgumentException {
        TabulatedHermite eos = family.getEos();
        family.clear();
        for (int iTOV = 0; iTOV < nTOVs; iTOV++) {
            TOVData rk4TOV = new TOVData(eos);
            double centralPressure = getCentralPressure(minFamilyPressure, maxFamilyPressure, nTOVs, iTOV, method);
            TOVBuilder.evolve(rk4TOV, eos, centralPressure, stepSize, outputEvery, minPressure);
            rk4TOV.computeSecondaries(eos);
            family.add(rk4TOV);
        }
        if (findMaxima) {
            TOVBuilder.findMaxima(family, stepSize, outputEvery, minPressure, minPressure);
        }
    }

    /**
     * Returns the next central pressure in the TOV Family filling.
     *
     * @param minFamilyPressure The minimum pressure of the TOV Family.
     * @param maxFamilyPressure The maximum pressure of the TOV family.
     * @param nTOVs The number of TOVs to create the family with.
     * @param iTOV The current TOV index being created (begins at 0).
     * @param method The method to use (Linear, Log, quadratic)
     * @return The central pressure of the current TOV being created.
     */
    private static double getCentralPressure(double minFamilyPressure, double maxFamilyPressure, int nTOVs, int iTOV, int method) {
        if (method == 1) { // Log.
            double logMin = Math.log10(minFamilyPressure);
            double logMax = Math.log10(maxFamilyPressure);
            double deltaLog = (logMax - logMin) / (nTOVs - 1);
            double logPc = logMin + iTOV * deltaLog;
            return Math.pow(10, logPc);
        } else if (method == 2) { // Quadratic
            double sqrtMin = Math.sqrt(minFamilyPressure);
            double sqrtMax = Math.sqrt(maxFamilyPressure);
            double deltaSqrt = (sqrtMax - sqrtMin) / (nTOVs - 1);
            double sqrtPc = sqrtMin + iTOV * deltaSqrt;
            return sqrtPc * sqrtPc;
        } else {
            double deltaP = (maxFamilyPressure - minFamilyPressure) / (nTOVs - 1);
            return minFamilyPressure + iTOV * deltaP;
        }
    }

    /**
     * Finds the maximum rest mass TOV of the equation of state and adds it to
     * the TOV family.
     *
     * @param family The current TOVFamily to find the maximum in.
     * @param stepSize the step size to use for the RK4
     * @param outputEvery how often to output data
     * @param minPressure the value of pressure to terminate evolution at (the
     * effective surface pressure)
     * @param deltaMass The tolerance on the rest mass with which to consider
     * the maximum converged.
     * @throws IllegalArgumentException If the current TOVFamily does not go
     * past the maximum central pressure for the equation of state.
     */
    public static void findMaxima(TOVFamily family, double stepSize, int outputEvery, double minPressure, double deltaMass) throws IllegalArgumentException {
        // Find the index of the current maxima.
        int iMaxima = 0;
        double maximumRestMass = 0;
        for (int i = 0; i < family.size(); i++) {
            if (family.get(i).getRestMass() > maximumRestMass) {
                iMaxima = i;
                maximumRestMass = family.get(i).getRestMass();
            } else if (family.get(i).getRestMass() == maximumRestMass) {
                throw new UnsupportedOperationException("Unable to handle rare case of equal mass points.");
            } else {
                i = family.size();
            }
        }
        if (iMaxima + 1 == family.size()) {
            throw new IllegalArgumentException("Cannot find maximum mass point: family does not straddle maximum.\nTry increasing the maximum pressure of the family.");
        }

        // Start refining.
        TOVData max = family.get(iMaxima);
        TOVData left = family.get(iMaxima - 1);
        TOVData right = family.get(iMaxima + 1);
        // Estimate the delta mass by taking the maximum current delta.
        double delta = maximumRestMass - right.getRestMass();
        if (left.getRestMass() < right.getRestMass()) {
            delta = maximumRestMass - left.getRestMass();
        }
        TabulatedHermite eos = family.getEos();
        int iStep = 0;
        while (delta > deltaMass && iStep < 30) {
            iStep++;
            double centralPleft = 0.5 * (left.getPressure(0) + max.getPressure(0));
            TOVData newLeft = new TOVData(eos);
            evolve(newLeft, eos, centralPleft, stepSize, outputEvery, minPressure);
            double centralPRight = 0.5 * (right.getPressure(0) + max.getPressure(0));
            TOVData newRight = new TOVData(eos);
            evolve(newRight, eos, centralPRight, stepSize, outputEvery, minPressure);
            // Handle cases.
            if (newLeft.getRestMass() > maximumRestMass) {
                // Case 1, newLeft is new maxima.
                maximumRestMass = newLeft.getRestMass();
                right = max;
                max = newLeft;
            } else if (newRight.getRestMass() > maximumRestMass) {
                // Case 2, newRight is new max.
                maximumRestMass = newRight.getRestMass();
                left = max;
                max = newRight;
            } else {
                // Case 3, maxima is still central point.
                left = newLeft;
                right = newRight;
            }
            delta = maximumRestMass - right.getRestMass();
            if (left.getRestMass() < right.getRestMass()) {
                delta = maximumRestMass - left.getRestMass();
            }
        }
        if (max.getPressure(0) > family.get(iMaxima).getPressure(0)) {
            family.setMaximum(iMaxima + 1, max);
        } else {
            family.setMaximum(iMaxima, max);
        }
    }
}
